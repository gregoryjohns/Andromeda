<#
.Synopsis
   Query VirusTotal for a hash analysis
.DESCRIPTION
   Passes a API and hash to VirusTotal and returns the results.
   The input will accept MD5 or SHA1 hashes or a mix of both. 
.EXAMPLE
   Get-VTResults -Hash 'MD5 or SHA1 hash' -Key 'A VirusTotal API key'
.EXAMPLE
   Another example of how to use this cmdlet
#>
function Get-VTResult
{
    [CmdletBinding()]
    [Alias()]
    [OutputType([int])]
    Param
    (
        # Hash to check on VirusTotal
        [Parameter(Mandatory=$true,
                   ValueFromPipelineByPropertyName=$true,
                   Position=0)]
        $Hash,

        # Virus Total API key
        [Parameter(Mandatory=$true,
                   ValueFromPipelineByPropertyName=$true,
                   Position=1)]
        $Key,

        # File to write data to
        [Parameter(Mandatory=$true,
                   ValueFromPipelineByPropertyName=$true,
                   Position=1)]
        $OutputFile
    )
    Begin
    {
        $Body = @()
        $Body = @{ resource = $Hash; apikey = $Key }
    }
    Process
    {
        $Scan = Invoke-RestMethod -Method 'POST' -Uri 'https://www.virustotal.com/vtapi/v2/file/report' -Body $Body
    }
    End
    {
        $Scan | export-csv -Path $ReportPath -Append -NoTypeInformation -Force
    }
}

#Function for sleep with on screen countdown and progress bar
function Start-SleepCountdown ($seconds) {
    $doneDT = (Get-Date).AddSeconds($seconds)
    while($doneDT -gt (Get-Date)) {
        $secondsLeft = $doneDT.Subtract((Get-Date)).TotalSeconds
        $percent = ($seconds - $secondsLeft) / $seconds * 100
        Write-Progress -Activity "Sleeping" -Status "Sleeping..." -SecondsRemaining $secondsLeft -PercentComplete $percent
        [System.Threading.Thread]::Sleep(500)
    }
    Write-Progress -Activity "Sleeping" -Status "Sleeping..." -SecondsRemaining 0 -Completed
}

<#
.Synopsis
   User facing function for submitting a list of hashes to VirusTotal and export the data to a CSV file.
.DESCRIPTION
   
.EXAMPLE
   Submit-HashAnalysis -HashPath 'c:\Directory\Hash.txt' -KeyPath 'C:\Directory\Keys.txt' -ReportPath 'C:\users\profile\desktop\HashResult.csv'
.EXAMPLE
   Submit-HashAnalysis 'c:\Directory\Hash.txt' 'C:\Directory\Keys.txt' 'C:\users\profile\desktop\HashResult.csv'
#>
function Submit-HashAnalysis
{
    [CmdletBinding()]
    [Alias()]
    [OutputType([int])]
    Param
    (
        # Full path to Hash file
        [Parameter(Mandatory=$true,
                   ValueFromPipelineByPropertyName=$true,
                   Position=0)]
        $HashPath,

        # Full path to API Key file
        [Parameter(Mandatory=$true,
                   ValueFromPipelineByPropertyName=$true,
                   Position=1)]
        $KeyPath,

        # Full path to write output file
        [Parameter(Mandatory=$true,
                   ValueFromPipelineByPropertyName=$true,
                   Position=2)]
        $ReportPath 
        )
    Begin
    {
        # Import and validate data
        if ($HashPath -like '*.txt') { $allhashes = Get-Content $hashpath}
        else {Write-host 'Hash input file must be either .txt or .csv format,' -ForegroundColor Red}
        if ($HashPath -like '*.csv') { $allhashes = Import-Csv  $hashpath}
        else {Write-host 'Hash input file must be either .txt or .csv format,' -ForegroundColor Red}
        
        if ($KeyPath -like '*.txt') { $APIKeys = Get-Content $KeyPath}
        else {Write-host 'API key input file must be either .txt or .csv format.' -ForegroundColor Red}
        if ($KeyPath -like '*.csv') { $APIKeys = Import-Csv  $KeyPath}
        else {Write-host 'API key input file must be either .txt or .csv format.' -ForegroundColor Red}
        
        #$APIKeys = Get-Content $APIKeypath

        #validate hash and API content
        if ($allhashes.count -gt 0) {Write-Host ($allhashes).count" hashes found in $hashpath." -ForegroundColor Green}
        else 
        {
            Write-Host "No hashes found in file located at $hashpath. `nCannot continue.  Ending job." -ForegroundColor Red
            Break
        }

        if ($APIKeys -gt 0) {Write-Host ($APIKeys).count "API keys will be used to process the hashes." -ForegroundColor Green}
        else
        {
            Write-host "No API Keys found in file located at $APIkeypath. `nCannot continue.  Ending job." -ForegroundColor Red
            Break   
        }

        if (Test-Path -Path $ReportPath) 
        {
            Write-Host "$ReportPath already exists.  The report file should not exists before begining.`nPlease use a new file name." -ForegroundColor Red
            Break
        }
    }
    Process
    {
        # Submit data to API
        $count = 0      # Sets the initial value of the API key iteration.

        foreach ($hash in $allhashes)
        {
            if ($count -eq ($APIKeys.count)){$count = 0}   #resets the API key iteration to the first key
    
            Write-Host "Querying $hash"
            $key = $APIKeys[$count]
            Get-VTResult -Hash $hash -Key $key -OutputFile $ReportPath
            #$Scan | export-csv -Path $Report -Append -NoTypeInformation -Force

            $count ++     #increments the API key to use the next key

            if ($count -eq $APIKeys.count)     # pauses the API query for 15 seconds to limit the query to 4 per minute
            {
                Write-Host 'Entering Sleep for 15 seconds' -ForegroundColor Yellow
                Start-Sleepcountdown -Seconds 15.2
            }
        }
    }
    End
    {
        # Count results to confirm completion
        #if ((Import-Csv -Path $ReportPath).count -eq $allhashes.count) {Write-Host "Hash analysis is complete and all hashes were processed and exported to $ReportPath" -ForegroundColor Green}
        #else {Write-Host 'There may have been an issue with processing, please review results.' -ForegroundColor Red}
        Write-Host 'Processing complete.' -ForegroundColor Green
    }
}

